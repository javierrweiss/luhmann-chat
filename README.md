# javierweiss/luhmann-chat

FIXME: my new application.

## Installation

Download from https://github.com/javierweiss/luhmann-chat

## Usage

FIXME: explanation

Run the project directly, via `:exec-fn`:

    $ clojure -X:run-x
    Hello, Clojure!

Run the project, overriding the name to be greeted:

    $ clojure -X:run-x :name '"Someone"'
    Hello, Someone!

Run the project directly, via `:main-opts` (`-m javierweiss.luhmann-chat`):

    $ clojure -M:run-m
    Hello, World!

Run the project, overriding the name to be greeted:

    $ clojure -M:run-m Via-Main
    Hello, Via-Main!

Run the project's tests (they'll fail until you edit them):

    $ clojure -T:build test

Run the project's CI pipeline and build an uberjar (this will fail until you edit the tests to pass):

    $ clojure -T:build ci

This will produce an updated `pom.xml` file with synchronized dependencies inside the `META-INF`
directory inside `target/classes` and the uberjar in `target`. You can update the version (and SCM tag)
information in generated `pom.xml` by updating `build.clj`.

If you don't want the `pom.xml` file in your project, you can remove it. The `ci` task will
still generate a minimal `pom.xml` as part of the `uber` task, unless you remove `version`
from `build.clj`.

Run that uberjar:

    $ java -jar target/luhmann-chat-0.1.0-SNAPSHOT.jar

If you remove `version` from `build.clj`, the uberjar will become `target/luhmann-chat-standalone.jar`.

## Desarrollo

Este proyecto usa libpython-clj. Para usar libpython-clj hay que tener en cuenta qué entorno de Python está instalado en nuestro computador.
Si no tenemos ni Conda, ni pyenv, sencillamente podemos hacer lo siguiente:

```clojure 
  (ns xxx.xxx
  (:require [libpython-clj2.require :refer [require-python]]
            [libpython-clj2.python :refer [py. py.. py.-] :as py]))
 ```
 Si, en cambio tenemos Conda, debemos hacerlo así, si no tenemos un entorno virtual activado:

 ```clojure
 (ns xxx.xxx
  (:require [libpython-clj2.python :as py :refer [py. py.. py.-]]))

  (py/initialize! :python-executable (str (System/getenv "CONDA_DIR") "/bin/python3.10") 
                  :library-path (str (System/getenv "CONDA_DIR") "/lib/libpython3.10.so"))
 ```
  O así, si tenemos un entorno virtual activado:
```clojure 
  (ns xxx.xxx
  (:require [libpython-clj2.python :as py]))
  
  (py/initialize! :python-executable "/opt/anaconda3/envs/my_env/bin/python3.7"
                :library-path "/opt/anaconda3/envs/my_env/lib/libpython3.7m.so")
```
Siempre es mejor tener un entorno virtual. Con Conda hacer lo siguiente:

 ```bash
 conda create -n <nombre-del-entorno>
 ```
 
 ```bash
 conda init bash
 ```

 ```bash
 conda activate <nombre-del-entorno>
 ```

Y si tenemos pyenv, debemos seguir estas instrucciones: https://clj-python.github.io/libpython-clj/environments.html

Y en todo caso, si nuestro JDK es java 17, debemos crear un alias en nuestro deps.edn con lo siguiente:

```edn 
:jvm-opts ["--add-modules" "jdk.incubator.foreign"
           "--enable-native-access=ALL-UNNAMED"]
```
Para importar paquetes primero hay que instalarlos con el gestor de paquetes que se esté usando, sea pip o conda. 
## Examples

...

### Bugs

...

### Any Other Sections
### That You Think
### Might be Useful

## License

Copyright © 2023 Jrivero

_EPLv1.0 is just the default for projects generated by `deps-new`: you are not_
_required to open source this project, nor are you required to use EPLv1.0!_
_Feel free to remove or change the `LICENSE` file and remove or update this_
_section of the `README.md` file!_

Distributed under the Eclipse Public License version 1.0.
